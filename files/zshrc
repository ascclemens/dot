############
# External #
############

source ~/.config/zsh/*.zsh

###################
# Standardization #
###################

export TERM=screen-256color

########
# Brew #
########

if [[ -e $(which brew) ]]; then
  export PATH=/usr/local/sbin:/usr/local/bin:$PATH
  if which jenv > /dev/null; then eval "$(jenv init -)"; fi
  if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi
  eval "$(thefuck --alias)"
fi

###########
# Antigen #
###########

[ -f /usr/local/Cellar/antigen/1/share/antigen.zsh ] && source /usr/local/Cellar/antigen/1/share/antigen.zsh

antigen use oh-my-zsh
antigen bundle rimraf/k
antigen bundle git
antigen bundle git-extras
antigen bundle brew
antigen bundle brew-cask
antigen bundle colorize
antigen bundle jump
antigen bundle mvn
antigen bundle cp
antigen bundle mosh
antigen bundle httpie
antigen bundle pip
antigen bundle python
antigen bundle tmuxinator
antigen bundle web-search
antigen bundle zsh-users/zsh-syntax-highlighting
antigen bundle peterhurford/up.zsh
antigen bundle rupa/z
antigen apply

##########
# iTerm2 #
##########

DISABLE_AUTO_TITLE=true
test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

#######
# zsh #
#######

zstyle ':completion:*' expand prefix suffix
zstyle ':completion:*' format ' Completing %d'
zstyle ':completion:*' group-name ''
zstyle ':completion:*' matcher-list '' 'r:|[._-]=* r:|=*'
zstyle ':completion:*' max-errors 1
zstyle :compinstall filename '/home/kyle/.zshrc'

autoload -U colors && colors
autoload -Uz compinit
compinit
HISTFILE=~/.histfile
HISTSIZE=1000
SAVEHIST=1000
bindkey -e

############
# Keybinds #
############

# create a zkbd compatible hash;
# to add other keys to this hash, see: man 5 terminfo
typeset -A key

key[Home]=${terminfo[khome]}
key[End]=${terminfo[kend]}
key[Insert]=${terminfo[kich1]}
key[Delete]=${terminfo[kdch1]}
key[Up]=${terminfo[kcuu1]}
key[Down]=${terminfo[kcud1]}
key[Left]=${terminfo[kcub1]}
key[Right]=${terminfo[kcuf1]}
key[PageUp]=${terminfo[kpp]}
key[PageDown]=${terminfo[knp]}

# setup key accordingly
[[ -n "${key[Home]}"     ]]  && bindkey  "${key[Home]}"     beginning-of-line
[[ -n "${key[End]}"      ]]  && bindkey  "${key[End]}"      end-of-line
[[ -n "${key[Insert]}"   ]]  && bindkey  "${key[Insert]}"   overwrite-mode
[[ -n "${key[Delete]}"   ]]  && bindkey  "${key[Delete]}"   delete-char
[[ -n "${key[Up]}"       ]]  && bindkey  "${key[Up]}"       up-line-or-history
[[ -n "${key[Down]}"     ]]  && bindkey  "${key[Down]}"     down-line-or-history
[[ -n "${key[Left]}"     ]]  && bindkey  "${key[Left]}"     backward-char
[[ -n "${key[Right]}"    ]]  && bindkey  "${key[Right]}"    forward-char
[[ -n "${key[Up]}"       ]]  && bindkey  "${key[Up]}"       history-beginning-search-backward
[[ -n "${key[Down]}"     ]]  && bindkey  "${key[Down]}"     history-beginning-search-forward
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"   history-search-backward
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}" history-search-forward

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
    function zle-line-init () {
        printf '%s' "${terminfo[smkx]}"
    }
    function zle-line-finish () {
        printf '%s' "${terminfo[rmkx]}"
    }
    zle -N zle-line-init
    zle -N zle-line-finish
fi

###########
# Globals #
###########

[[ -e /usr/libexec/java_home ]] && export JAVA_HOME=$(/usr/libexec/java_home)
export EDITOR="reattach-to-user-namespace subl -wn"
export MONO_GAC_PREFIX="/usr/local"
export GPG_TTY=`tty`
export PATH="$PATH:$HOME/.rvm/bin"

###########
# Aliases #
###########

alias airvpn-kill="ps ax | grep -i airvpn | cut -f 1 -d ' ' | sed -n 2,3p | xargs kill -9"
alias battery="pmset -g batt"
[[ -e $(which hub) ]] && alias git=hub
alias ka="k -A"
alias ls="ls -Gp"
alias lsa="ls -A"
alias mux=tmuxinator
alias pseudo=sudo
alias subl="reattach-to-user-namespace subl"
alias vlc="reattach-to-user-namespace /Applications/VLC.app/Contents/MacOS/VLC"

# Added by termtile (https://github.com/apaszke/termtile)
alias mwul='osascript ~/.termtile/tile.scpt up left'
alias mwur='osascript ~/.termtile/tile.scpt up right'
alias mwdl='osascript ~/.termtile/tile.scpt down left'
alias mwdr='osascript ~/.termtile/tile.scpt down right'
alias mwll='osascript ~/.termtile/tile.scpt left'
alias mwrr='osascript ~/.termtile/tile.scpt right'
alias mwup='osascript ~/.termtile/tile.scpt up'
alias mwdown='osascript ~/.termtile/tile.scpt down'
alias mwbig='osascript ~/.termtile/resize.scpt '
alias mwcen='osascript ~/.termtile/center.scpt '
alias mwmax='osascript ~/.termtile/maximize.scpt '
alias mwsn='osascript ~/.termtile/changeScreen.scpt next'
alias mwdef='osascript ~/.termtile/resize.scpt 573 427'

#############
# Functions #
#############

mkdircd() {
  mkdir -p "$*";
  cd "$*";
}

mvln() {
  mv $1 $2
  ln -s $(realpath $2) $(realpath $1);
}

movie() {
  geeknote show "$1" | tr '\n' '|' | cut -d'|' -f7- | tr '|' '\n' | sed '/^$/d' | sed '/^\* \[x/d' | gshuf -n 1
}

#
# Defines transfer alias and provides easy command line file and folder sharing.
#
# Authors:
#   Remco Verhoef <remco@dutchcoders.io>
#

curl --version 2>&1 > /dev/null
if [ $? -ne 0 ]; then
  echo "Could not find curl."
  return 1
fi

transfer() {
    # check arguments
    if [ $# -eq 0 ];
    then
        echo "No arguments specified. Usage:\necho transfer /tmp/test.md\ncat /tmp/test.md | transfer test.md"
        return 1
    fi

    # get temporarily filename, output is written to this file show progress can be showed
    tmpfile=$( mktemp -t transferXXX )

    # upload stdin or file
    file=$1

    if tty -s;
    then
        basefile=$(basename "$file" | sed -e 's/[^a-zA-Z0-9._-]/-/g')

        if [ ! -e $file ];
        then
            echo "File $file doesn't exist."
            return 1
        fi

        if [ -d $file ];
        then
            # zip directory and transfer
            zipfile=$( mktemp -t transferXXX.zip )
            cd $(dirname $file) && zip -r -q - $(basename $file) >> $zipfile
            curl --progress-bar --upload-file "$zipfile" "https://transfer.sh/$basefile.zip" >> $tmpfile
            rm -f $zipfile
        else
            # transfer file
            curl --progress-bar --upload-file "$file" "https://transfer.sh/$basefile" >> $tmpfile
        fi
    else
        # transfer pipe
        curl --progress-bar --upload-file "-" "https://transfer.sh/$file" >> $tmpfile
    fi

    # cat output link
    cat $tmpfile

    # cleanup
    rm -f $tmpfile
}

###########
# Prompts #
###########

export PROMPT="$(~/.prompt/prompt PROMPT)"
export RPROMPT="$(~/.prompt/prompt RPROMPT)"

function git_dirty {
  [[ $(git diff --shortstat 2> /dev/null | tail -n1) != "" ]] && echo "*"
}

function git_status {
  if [[ "x$(git_dirty)" == "x" ]]; then
    echo "%{$FG[002]%}"
  else
    echo "%{$FG[009]%}"
  fi
}

function git_spark {
  if [[ "x$(git status 2> /dev/null)" != "x" ]]; then
    echo " $(git freq $(date '+%Y-%m-%d') -7 | spark)"
  fi
}

function update_git_color {
  ZSH_THEME_GIT_PROMPT_PREFIX=" $(git_status)"
  ZSH_THEME_GIT_PROMPT_SUFFIX="%{$reset_color%}$(git_spark)"
}
ZSH_THEME_GIT_PROMPT_DIRTY=""
ZSH_THEME_GIT_PROMPT_CLEAN=""

function echo_blank() {
  echo
}
precmd_functions+=echo_blank
precmd_functions+=update_git_color

###########
# Sources #
###########

[ -f /Users/kyleclemens/.travis/travis.sh ] && source /Users/kyleclemens/.travis/travis.sh
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
[ -n "$DESK_ENV" ] && source "$DESK_ENV" || true
[[ -s "$HOME/.qfc/bin/qfc.sh" ]] && source "$HOME/.qfc/bin/qfc.sh"

#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!!
export SDKMAN_DIR="/Users/kyleclemens/.sdkman"
[[ -s "/Users/kyleclemens/.sdkman/bin/sdkman-init.sh" ]] && source "/Users/kyleclemens/.sdkman/bin/sdkman-init.sh"

########
# Rust #
########

export PATH=$PATH:~/.cargo/bin

###########
# Cleanup #
###########

# Sort and clean $PATH. This should always remain at the end of the file.
[[ -e $(which path_sort) ]] && export PATH=$(path_sort --homebrew)
